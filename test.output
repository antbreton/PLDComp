État 91 conflits: 13 décalage/réduction
État 105 conflits: 1 décalage/réduction


Grammaire

    0 $accept: axiome $end

    1 axiome: programme

    2 suffixe_tab: CROCHOUVR valeur_variable CROCHFERM
    3            | %empty

    4 declaration_droite: type IDENTIFIANT suffixe_tab

    5 separateur_decl: separateur_decl VIRGULE IDENTIFIANT
    6                | %empty

    7 declaration: declaration_droite separateur_decl
    8            | declaration_droite separateur_decl EGAL_AFFECTATION expression

    9 fonction: prototype PV
   10         | prototype bloc

   11 parametre_declaration: parametre_declaration VIRGULE declaration_droite
   12                      | declaration_droite

   13 prototype: type IDENTIFIANT PAROUVR parametre_declaration PARFERM

   14 appel_fonction: IDENTIFIANT PAROUVR liste_expression PARFERM

   15 liste_expression: expression VIRGULE liste_expression
   16                 | expression

   17 type: INT32
   18     | INT64
   19     | CHAR
   20     | VOID

   21 instrv: expression PV
   22       | structure_de_controle
   23       | bloc
   24       | RETURN CROCHOUVR expression CROCHFERM PV
   25       | PV

   26 instr: instrv declaration PV

   27 programme: programme fonction
   28          | programme declaration
   29          | %empty

   30 prototype: type IDENTIFIANT PAROUVR parametres_declaration PARFERM

   31 parametres_declaration: type

   32 expression: NOT expression
   33           | expression operateurbinaire expression
   34           | PAROUVR expression PARFERM
   35           | appel_fonction
   36           | affectation
   37           | IDENTIFIANT
   38           | valeur_variable

   39 valeur_variable: VAL
   40                | CARACTERE

   41 affectation: IDENTIFIANT EGAL_AFFECTATION expression

   42 operateurbinaire: AND
   43                 | OR
   44                 | INF
   45                 | SUP
   46                 | INFEGAL
   47                 | SUPEGAL
   48                 | EGALEGAL
   49                 | DIFF
   50                 | PLUS
   51                 | MOINS
   52                 | MULT
   53                 | DIV
   54                 | DIVEUCL

   55 structure_de_controle: bloc_if
   56                      | bloc_boucle

   57 bloc_if: IF PAROUVR expression PARFERM instrv ELSE instrv
   58        | IF PAROUVR expression PARFERM instrv

   59 bloc_boucle: bloc_for
   60            | bloc_while

   61 expression_for: expression
   62               | %empty

   63 bloc_for: FOR PAROUVR expression_for PV expression_for PV expression_for PV PARFERM instrv

   64 bloc_while: WHILE PAROUVR expression PARFERM instrv

   65 bloc: ACCOLOUVR contenu_bloc ACCOLFERM

   66 contenu_bloc: contenu_bloc instr
   67             | instr


Terminaux, suivis des règles où ils apparaissent

$end (0) 0
error (256)
IDENTIFIANT (258) 4 5 13 14 30 37 41
PAROUVR (259) 13 14 30 34 57 58 63 64
PARFERM (260) 13 14 30 34 57 58 63 64
INT32 (261) 17
INT64 (262) 18
CHAR (263) 19
VOID (264) 20
PV (265) 9 21 24 25 26 63
RETURN (266) 24
CROCHOUVR (267) 2 24
CROCHFERM (268) 2 24
ACCOLOUVR (269) 65
ACCOLFERM (270) 65
IF (271) 57 58
ELSE (272) 57
WHILE (273) 64
FOR (274) 63
VIRGULE (275) 5 11 15
EGALEGAL (276) 48
EGAL_AFFECTATION (277) 8 41
VAL (278) 39
CARACTERE (279) 40
AND (280) 42
OR (281) 43
INF (282) 44
SUP (283) 45
INFEGAL (284) 46
SUPEGAL (285) 47
DIFF (286) 49
PLUS (287) 50
MOINS (288) 51
MULT (289) 52
DIV (290) 53
DIVEUCL (291) 54
NOT (292) 32


Non-terminaux, suivis des règles où ils apparaissent

$accept (38)
    à gauche: 0
axiome (39)
    à gauche: 1, à droite: 0
suffixe_tab (40)
    à gauche: 2 3, à droite: 4
declaration_droite (41)
    à gauche: 4, à droite: 7 8 11 12
separateur_decl (42)
    à gauche: 5 6, à droite: 5 7 8
declaration (43)
    à gauche: 7 8, à droite: 26 28
fonction (44)
    à gauche: 9 10, à droite: 27
parametre_declaration (45)
    à gauche: 11 12, à droite: 11 13
prototype (46)
    à gauche: 13 30, à droite: 9 10
appel_fonction (47)
    à gauche: 14, à droite: 35
liste_expression (48)
    à gauche: 15 16, à droite: 14 15
type (49)
    à gauche: 17 18 19 20, à droite: 4 13 30 31
instrv (50)
    à gauche: 21 22 23 24 25, à droite: 26 57 58 63 64
instr (51)
    à gauche: 26, à droite: 66 67
programme (52)
    à gauche: 27 28 29, à droite: 1 27 28
parametres_declaration (53)
    à gauche: 31, à droite: 30
expression (54)
    à gauche: 32 33 34 35 36 37 38, à droite: 8 15 16 21 24 32 33
    34 41 57 58 61 64
valeur_variable (55)
    à gauche: 39 40, à droite: 2 38
affectation (56)
    à gauche: 41, à droite: 36
operateurbinaire (57)
    à gauche: 42 43 44 45 46 47 48 49 50 51 52 53 54, à droite: 33
structure_de_controle (58)
    à gauche: 55 56, à droite: 22
bloc_if (59)
    à gauche: 57 58, à droite: 55
bloc_boucle (60)
    à gauche: 59 60, à droite: 56
expression_for (61)
    à gauche: 61 62, à droite: 63
bloc_for (62)
    à gauche: 63, à droite: 59
bloc_while (63)
    à gauche: 64, à droite: 60
bloc (64)
    à gauche: 65, à droite: 10 23
contenu_bloc (65)
    à gauche: 66 67, à droite: 65 66


État 0

    0 $accept: . axiome $end

    $défaut  réduction par utilisation de la règle 29 (programme)

    axiome     aller à l'état 1
    programme  aller à l'état 2


État 1

    0 $accept: axiome . $end

    $end  décalage et aller à l'état 3


État 2

    1 axiome: programme .
   27 programme: programme . fonction
   28          | programme . declaration

    INT32  décalage et aller à l'état 4
    INT64  décalage et aller à l'état 5
    CHAR   décalage et aller à l'état 6
    VOID   décalage et aller à l'état 7

    $défaut  réduction par utilisation de la règle 1 (axiome)

    declaration_droite  aller à l'état 8
    declaration         aller à l'état 9
    fonction            aller à l'état 10
    prototype           aller à l'état 11
    type                aller à l'état 12


État 3

    0 $accept: axiome $end .

    $défaut  accepter


État 4

   17 type: INT32 .

    $défaut  réduction par utilisation de la règle 17 (type)


État 5

   18 type: INT64 .

    $défaut  réduction par utilisation de la règle 18 (type)


État 6

   19 type: CHAR .

    $défaut  réduction par utilisation de la règle 19 (type)


État 7

   20 type: VOID .

    $défaut  réduction par utilisation de la règle 20 (type)


État 8

    7 declaration: declaration_droite . separateur_decl
    8            | declaration_droite . separateur_decl EGAL_AFFECTATION expression

    $défaut  réduction par utilisation de la règle 6 (separateur_decl)

    separateur_decl  aller à l'état 13


État 9

   28 programme: programme declaration .

    $défaut  réduction par utilisation de la règle 28 (programme)


État 10

   27 programme: programme fonction .

    $défaut  réduction par utilisation de la règle 27 (programme)


État 11

    9 fonction: prototype . PV
   10         | prototype . bloc

    PV         décalage et aller à l'état 14
    ACCOLOUVR  décalage et aller à l'état 15

    bloc  aller à l'état 16


État 12

    4 declaration_droite: type . IDENTIFIANT suffixe_tab
   13 prototype: type . IDENTIFIANT PAROUVR parametre_declaration PARFERM
   30          | type . IDENTIFIANT PAROUVR parametres_declaration PARFERM

    IDENTIFIANT  décalage et aller à l'état 17


État 13

    5 separateur_decl: separateur_decl . VIRGULE IDENTIFIANT
    7 declaration: declaration_droite separateur_decl .
    8            | declaration_droite separateur_decl . EGAL_AFFECTATION expression

    VIRGULE           décalage et aller à l'état 18
    EGAL_AFFECTATION  décalage et aller à l'état 19

    $défaut  réduction par utilisation de la règle 7 (declaration)


État 14

    9 fonction: prototype PV .

    $défaut  réduction par utilisation de la règle 9 (fonction)


État 15

   65 bloc: ACCOLOUVR . contenu_bloc ACCOLFERM

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    PV           décalage et aller à l'état 22
    RETURN       décalage et aller à l'état 23
    ACCOLOUVR    décalage et aller à l'état 15
    IF           décalage et aller à l'état 24
    WHILE        décalage et aller à l'état 25
    FOR          décalage et aller à l'état 26
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction         aller à l'état 30
    instrv                 aller à l'état 31
    instr                  aller à l'état 32
    expression             aller à l'état 33
    valeur_variable        aller à l'état 34
    affectation            aller à l'état 35
    structure_de_controle  aller à l'état 36
    bloc_if                aller à l'état 37
    bloc_boucle            aller à l'état 38
    bloc_for               aller à l'état 39
    bloc_while             aller à l'état 40
    bloc                   aller à l'état 41
    contenu_bloc           aller à l'état 42


État 16

   10 fonction: prototype bloc .

    $défaut  réduction par utilisation de la règle 10 (fonction)


État 17

    4 declaration_droite: type IDENTIFIANT . suffixe_tab
   13 prototype: type IDENTIFIANT . PAROUVR parametre_declaration PARFERM
   30          | type IDENTIFIANT . PAROUVR parametres_declaration PARFERM

    PAROUVR    décalage et aller à l'état 43
    CROCHOUVR  décalage et aller à l'état 44

    $défaut  réduction par utilisation de la règle 3 (suffixe_tab)

    suffixe_tab  aller à l'état 45


État 18

    5 separateur_decl: separateur_decl VIRGULE . IDENTIFIANT

    IDENTIFIANT  décalage et aller à l'état 46


État 19

    8 declaration: declaration_droite separateur_decl EGAL_AFFECTATION . expression

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction   aller à l'état 30
    expression       aller à l'état 47
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35


État 20

   14 appel_fonction: IDENTIFIANT . PAROUVR liste_expression PARFERM
   37 expression: IDENTIFIANT .
   41 affectation: IDENTIFIANT . EGAL_AFFECTATION expression

    PAROUVR           décalage et aller à l'état 48
    EGAL_AFFECTATION  décalage et aller à l'état 49

    $défaut  réduction par utilisation de la règle 37 (expression)


État 21

   34 expression: PAROUVR . expression PARFERM

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction   aller à l'état 30
    expression       aller à l'état 50
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35


État 22

   25 instrv: PV .

    $défaut  réduction par utilisation de la règle 25 (instrv)


État 23

   24 instrv: RETURN . CROCHOUVR expression CROCHFERM PV

    CROCHOUVR  décalage et aller à l'état 51


État 24

   57 bloc_if: IF . PAROUVR expression PARFERM instrv ELSE instrv
   58        | IF . PAROUVR expression PARFERM instrv

    PAROUVR  décalage et aller à l'état 52


État 25

   64 bloc_while: WHILE . PAROUVR expression PARFERM instrv

    PAROUVR  décalage et aller à l'état 53


État 26

   63 bloc_for: FOR . PAROUVR expression_for PV expression_for PV expression_for PV PARFERM instrv

    PAROUVR  décalage et aller à l'état 54


État 27

   39 valeur_variable: VAL .

    $défaut  réduction par utilisation de la règle 39 (valeur_variable)


État 28

   40 valeur_variable: CARACTERE .

    $défaut  réduction par utilisation de la règle 40 (valeur_variable)


État 29

   32 expression: NOT . expression

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction   aller à l'état 30
    expression       aller à l'état 55
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35


État 30

   35 expression: appel_fonction .

    $défaut  réduction par utilisation de la règle 35 (expression)


État 31

   26 instr: instrv . declaration PV

    INT32  décalage et aller à l'état 4
    INT64  décalage et aller à l'état 5
    CHAR   décalage et aller à l'état 6
    VOID   décalage et aller à l'état 7

    declaration_droite  aller à l'état 8
    declaration         aller à l'état 56
    type                aller à l'état 57


État 32

   67 contenu_bloc: instr .

    $défaut  réduction par utilisation de la règle 67 (contenu_bloc)


État 33

   21 instrv: expression . PV
   33 expression: expression . operateurbinaire expression

    PV        décalage et aller à l'état 58
    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    operateurbinaire  aller à l'état 72


État 34

   38 expression: valeur_variable .

    $défaut  réduction par utilisation de la règle 38 (expression)


État 35

   36 expression: affectation .

    $défaut  réduction par utilisation de la règle 36 (expression)


État 36

   22 instrv: structure_de_controle .

    $défaut  réduction par utilisation de la règle 22 (instrv)


État 37

   55 structure_de_controle: bloc_if .

    $défaut  réduction par utilisation de la règle 55 (structure_de_controle)


État 38

   56 structure_de_controle: bloc_boucle .

    $défaut  réduction par utilisation de la règle 56 (structure_de_controle)


État 39

   59 bloc_boucle: bloc_for .

    $défaut  réduction par utilisation de la règle 59 (bloc_boucle)


État 40

   60 bloc_boucle: bloc_while .

    $défaut  réduction par utilisation de la règle 60 (bloc_boucle)


État 41

   23 instrv: bloc .

    $défaut  réduction par utilisation de la règle 23 (instrv)


État 42

   65 bloc: ACCOLOUVR contenu_bloc . ACCOLFERM
   66 contenu_bloc: contenu_bloc . instr

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    PV           décalage et aller à l'état 22
    RETURN       décalage et aller à l'état 23
    ACCOLOUVR    décalage et aller à l'état 15
    ACCOLFERM    décalage et aller à l'état 73
    IF           décalage et aller à l'état 24
    WHILE        décalage et aller à l'état 25
    FOR          décalage et aller à l'état 26
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction         aller à l'état 30
    instrv                 aller à l'état 31
    instr                  aller à l'état 74
    expression             aller à l'état 33
    valeur_variable        aller à l'état 34
    affectation            aller à l'état 35
    structure_de_controle  aller à l'état 36
    bloc_if                aller à l'état 37
    bloc_boucle            aller à l'état 38
    bloc_for               aller à l'état 39
    bloc_while             aller à l'état 40
    bloc                   aller à l'état 41


État 43

   13 prototype: type IDENTIFIANT PAROUVR . parametre_declaration PARFERM
   30          | type IDENTIFIANT PAROUVR . parametres_declaration PARFERM

    INT32  décalage et aller à l'état 4
    INT64  décalage et aller à l'état 5
    CHAR   décalage et aller à l'état 6
    VOID   décalage et aller à l'état 7

    declaration_droite      aller à l'état 75
    parametre_declaration   aller à l'état 76
    type                    aller à l'état 77
    parametres_declaration  aller à l'état 78


État 44

    2 suffixe_tab: CROCHOUVR . valeur_variable CROCHFERM

    VAL        décalage et aller à l'état 27
    CARACTERE  décalage et aller à l'état 28

    valeur_variable  aller à l'état 79


État 45

    4 declaration_droite: type IDENTIFIANT suffixe_tab .

    $défaut  réduction par utilisation de la règle 4 (declaration_droite)


État 46

    5 separateur_decl: separateur_decl VIRGULE IDENTIFIANT .

    $défaut  réduction par utilisation de la règle 5 (separateur_decl)


État 47

    8 declaration: declaration_droite separateur_decl EGAL_AFFECTATION expression .
   33 expression: expression . operateurbinaire expression

    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    $défaut  réduction par utilisation de la règle 8 (declaration)

    operateurbinaire  aller à l'état 72


État 48

   14 appel_fonction: IDENTIFIANT PAROUVR . liste_expression PARFERM

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction    aller à l'état 30
    liste_expression  aller à l'état 80
    expression        aller à l'état 81
    valeur_variable   aller à l'état 34
    affectation       aller à l'état 35


État 49

   41 affectation: IDENTIFIANT EGAL_AFFECTATION . expression

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction   aller à l'état 30
    expression       aller à l'état 82
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35


État 50

   33 expression: expression . operateurbinaire expression
   34           | PAROUVR expression . PARFERM

    PARFERM   décalage et aller à l'état 83
    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    operateurbinaire  aller à l'état 72


État 51

   24 instrv: RETURN CROCHOUVR . expression CROCHFERM PV

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction   aller à l'état 30
    expression       aller à l'état 84
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35


État 52

   57 bloc_if: IF PAROUVR . expression PARFERM instrv ELSE instrv
   58        | IF PAROUVR . expression PARFERM instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction   aller à l'état 30
    expression       aller à l'état 85
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35


État 53

   64 bloc_while: WHILE PAROUVR . expression PARFERM instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction   aller à l'état 30
    expression       aller à l'état 86
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35


État 54

   63 bloc_for: FOR PAROUVR . expression_for PV expression_for PV expression_for PV PARFERM instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    $défaut  réduction par utilisation de la règle 62 (expression_for)

    appel_fonction   aller à l'état 30
    expression       aller à l'état 87
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35
    expression_for   aller à l'état 88


État 55

   32 expression: NOT expression .
   33           | expression . operateurbinaire expression

    $défaut  réduction par utilisation de la règle 32 (expression)

    operateurbinaire  aller à l'état 72


État 56

   26 instr: instrv declaration . PV

    PV  décalage et aller à l'état 89


État 57

    4 declaration_droite: type . IDENTIFIANT suffixe_tab

    IDENTIFIANT  décalage et aller à l'état 90


État 58

   21 instrv: expression PV .

    $défaut  réduction par utilisation de la règle 21 (instrv)


État 59

   48 operateurbinaire: EGALEGAL .

    $défaut  réduction par utilisation de la règle 48 (operateurbinaire)


État 60

   42 operateurbinaire: AND .

    $défaut  réduction par utilisation de la règle 42 (operateurbinaire)


État 61

   43 operateurbinaire: OR .

    $défaut  réduction par utilisation de la règle 43 (operateurbinaire)


État 62

   44 operateurbinaire: INF .

    $défaut  réduction par utilisation de la règle 44 (operateurbinaire)


État 63

   45 operateurbinaire: SUP .

    $défaut  réduction par utilisation de la règle 45 (operateurbinaire)


État 64

   46 operateurbinaire: INFEGAL .

    $défaut  réduction par utilisation de la règle 46 (operateurbinaire)


État 65

   47 operateurbinaire: SUPEGAL .

    $défaut  réduction par utilisation de la règle 47 (operateurbinaire)


État 66

   49 operateurbinaire: DIFF .

    $défaut  réduction par utilisation de la règle 49 (operateurbinaire)


État 67

   50 operateurbinaire: PLUS .

    $défaut  réduction par utilisation de la règle 50 (operateurbinaire)


État 68

   51 operateurbinaire: MOINS .

    $défaut  réduction par utilisation de la règle 51 (operateurbinaire)


État 69

   52 operateurbinaire: MULT .

    $défaut  réduction par utilisation de la règle 52 (operateurbinaire)


État 70

   53 operateurbinaire: DIV .

    $défaut  réduction par utilisation de la règle 53 (operateurbinaire)


État 71

   54 operateurbinaire: DIVEUCL .

    $défaut  réduction par utilisation de la règle 54 (operateurbinaire)


État 72

   33 expression: expression operateurbinaire . expression

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction   aller à l'état 30
    expression       aller à l'état 91
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35


État 73

   65 bloc: ACCOLOUVR contenu_bloc ACCOLFERM .

    $défaut  réduction par utilisation de la règle 65 (bloc)


État 74

   66 contenu_bloc: contenu_bloc instr .

    $défaut  réduction par utilisation de la règle 66 (contenu_bloc)


État 75

   12 parametre_declaration: declaration_droite .

    $défaut  réduction par utilisation de la règle 12 (parametre_declaration)


État 76

   11 parametre_declaration: parametre_declaration . VIRGULE declaration_droite
   13 prototype: type IDENTIFIANT PAROUVR parametre_declaration . PARFERM

    PARFERM  décalage et aller à l'état 92
    VIRGULE  décalage et aller à l'état 93


État 77

    4 declaration_droite: type . IDENTIFIANT suffixe_tab
   31 parametres_declaration: type .

    IDENTIFIANT  décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 31 (parametres_declaration)


État 78

   30 prototype: type IDENTIFIANT PAROUVR parametres_declaration . PARFERM

    PARFERM  décalage et aller à l'état 94


État 79

    2 suffixe_tab: CROCHOUVR valeur_variable . CROCHFERM

    CROCHFERM  décalage et aller à l'état 95


État 80

   14 appel_fonction: IDENTIFIANT PAROUVR liste_expression . PARFERM

    PARFERM  décalage et aller à l'état 96


État 81

   15 liste_expression: expression . VIRGULE liste_expression
   16                 | expression .
   33 expression: expression . operateurbinaire expression

    VIRGULE   décalage et aller à l'état 97
    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    $défaut  réduction par utilisation de la règle 16 (liste_expression)

    operateurbinaire  aller à l'état 72


État 82

   33 expression: expression . operateurbinaire expression
   41 affectation: IDENTIFIANT EGAL_AFFECTATION expression .

    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    $défaut  réduction par utilisation de la règle 41 (affectation)

    operateurbinaire  aller à l'état 72


État 83

   34 expression: PAROUVR expression PARFERM .

    $défaut  réduction par utilisation de la règle 34 (expression)


État 84

   24 instrv: RETURN CROCHOUVR expression . CROCHFERM PV
   33 expression: expression . operateurbinaire expression

    CROCHFERM  décalage et aller à l'état 98
    EGALEGAL   décalage et aller à l'état 59
    AND        décalage et aller à l'état 60
    OR         décalage et aller à l'état 61
    INF        décalage et aller à l'état 62
    SUP        décalage et aller à l'état 63
    INFEGAL    décalage et aller à l'état 64
    SUPEGAL    décalage et aller à l'état 65
    DIFF       décalage et aller à l'état 66
    PLUS       décalage et aller à l'état 67
    MOINS      décalage et aller à l'état 68
    MULT       décalage et aller à l'état 69
    DIV        décalage et aller à l'état 70
    DIVEUCL    décalage et aller à l'état 71

    operateurbinaire  aller à l'état 72


État 85

   33 expression: expression . operateurbinaire expression
   57 bloc_if: IF PAROUVR expression . PARFERM instrv ELSE instrv
   58        | IF PAROUVR expression . PARFERM instrv

    PARFERM   décalage et aller à l'état 99
    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    operateurbinaire  aller à l'état 72


État 86

   33 expression: expression . operateurbinaire expression
   64 bloc_while: WHILE PAROUVR expression . PARFERM instrv

    PARFERM   décalage et aller à l'état 100
    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    operateurbinaire  aller à l'état 72


État 87

   33 expression: expression . operateurbinaire expression
   61 expression_for: expression .

    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    $défaut  réduction par utilisation de la règle 61 (expression_for)

    operateurbinaire  aller à l'état 72


État 88

   63 bloc_for: FOR PAROUVR expression_for . PV expression_for PV expression_for PV PARFERM instrv

    PV  décalage et aller à l'état 101


État 89

   26 instr: instrv declaration PV .

    $défaut  réduction par utilisation de la règle 26 (instr)


État 90

    4 declaration_droite: type IDENTIFIANT . suffixe_tab

    CROCHOUVR  décalage et aller à l'état 44

    $défaut  réduction par utilisation de la règle 3 (suffixe_tab)

    suffixe_tab  aller à l'état 45


État 91

   33 expression: expression . operateurbinaire expression
   33           | expression operateurbinaire expression .

    EGALEGAL  décalage et aller à l'état 59
    AND       décalage et aller à l'état 60
    OR        décalage et aller à l'état 61
    INF       décalage et aller à l'état 62
    SUP       décalage et aller à l'état 63
    INFEGAL   décalage et aller à l'état 64
    SUPEGAL   décalage et aller à l'état 65
    DIFF      décalage et aller à l'état 66
    PLUS      décalage et aller à l'état 67
    MOINS     décalage et aller à l'état 68
    MULT      décalage et aller à l'état 69
    DIV       décalage et aller à l'état 70
    DIVEUCL   décalage et aller à l'état 71

    EGALEGAL  [réduction par utilisation de la règle 33 (expression)]
    AND       [réduction par utilisation de la règle 33 (expression)]
    OR        [réduction par utilisation de la règle 33 (expression)]
    INF       [réduction par utilisation de la règle 33 (expression)]
    SUP       [réduction par utilisation de la règle 33 (expression)]
    INFEGAL   [réduction par utilisation de la règle 33 (expression)]
    SUPEGAL   [réduction par utilisation de la règle 33 (expression)]
    DIFF      [réduction par utilisation de la règle 33 (expression)]
    PLUS      [réduction par utilisation de la règle 33 (expression)]
    MOINS     [réduction par utilisation de la règle 33 (expression)]
    MULT      [réduction par utilisation de la règle 33 (expression)]
    DIV       [réduction par utilisation de la règle 33 (expression)]
    DIVEUCL   [réduction par utilisation de la règle 33 (expression)]
    $défaut  réduction par utilisation de la règle 33 (expression)

    operateurbinaire  aller à l'état 72


État 92

   13 prototype: type IDENTIFIANT PAROUVR parametre_declaration PARFERM .

    $défaut  réduction par utilisation de la règle 13 (prototype)


État 93

   11 parametre_declaration: parametre_declaration VIRGULE . declaration_droite

    INT32  décalage et aller à l'état 4
    INT64  décalage et aller à l'état 5
    CHAR   décalage et aller à l'état 6
    VOID   décalage et aller à l'état 7

    declaration_droite  aller à l'état 102
    type                aller à l'état 57


État 94

   30 prototype: type IDENTIFIANT PAROUVR parametres_declaration PARFERM .

    $défaut  réduction par utilisation de la règle 30 (prototype)


État 95

    2 suffixe_tab: CROCHOUVR valeur_variable CROCHFERM .

    $défaut  réduction par utilisation de la règle 2 (suffixe_tab)


État 96

   14 appel_fonction: IDENTIFIANT PAROUVR liste_expression PARFERM .

    $défaut  réduction par utilisation de la règle 14 (appel_fonction)


État 97

   15 liste_expression: expression VIRGULE . liste_expression

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction    aller à l'état 30
    liste_expression  aller à l'état 103
    expression        aller à l'état 81
    valeur_variable   aller à l'état 34
    affectation       aller à l'état 35


État 98

   24 instrv: RETURN CROCHOUVR expression CROCHFERM . PV

    PV  décalage et aller à l'état 104


État 99

   57 bloc_if: IF PAROUVR expression PARFERM . instrv ELSE instrv
   58        | IF PAROUVR expression PARFERM . instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    PV           décalage et aller à l'état 22
    RETURN       décalage et aller à l'état 23
    ACCOLOUVR    décalage et aller à l'état 15
    IF           décalage et aller à l'état 24
    WHILE        décalage et aller à l'état 25
    FOR          décalage et aller à l'état 26
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction         aller à l'état 30
    instrv                 aller à l'état 105
    expression             aller à l'état 33
    valeur_variable        aller à l'état 34
    affectation            aller à l'état 35
    structure_de_controle  aller à l'état 36
    bloc_if                aller à l'état 37
    bloc_boucle            aller à l'état 38
    bloc_for               aller à l'état 39
    bloc_while             aller à l'état 40
    bloc                   aller à l'état 41


État 100

   64 bloc_while: WHILE PAROUVR expression PARFERM . instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    PV           décalage et aller à l'état 22
    RETURN       décalage et aller à l'état 23
    ACCOLOUVR    décalage et aller à l'état 15
    IF           décalage et aller à l'état 24
    WHILE        décalage et aller à l'état 25
    FOR          décalage et aller à l'état 26
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction         aller à l'état 30
    instrv                 aller à l'état 106
    expression             aller à l'état 33
    valeur_variable        aller à l'état 34
    affectation            aller à l'état 35
    structure_de_controle  aller à l'état 36
    bloc_if                aller à l'état 37
    bloc_boucle            aller à l'état 38
    bloc_for               aller à l'état 39
    bloc_while             aller à l'état 40
    bloc                   aller à l'état 41


État 101

   63 bloc_for: FOR PAROUVR expression_for PV . expression_for PV expression_for PV PARFERM instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    $défaut  réduction par utilisation de la règle 62 (expression_for)

    appel_fonction   aller à l'état 30
    expression       aller à l'état 87
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35
    expression_for   aller à l'état 107


État 102

   11 parametre_declaration: parametre_declaration VIRGULE declaration_droite .

    $défaut  réduction par utilisation de la règle 11 (parametre_declaration)


État 103

   15 liste_expression: expression VIRGULE liste_expression .

    $défaut  réduction par utilisation de la règle 15 (liste_expression)


État 104

   24 instrv: RETURN CROCHOUVR expression CROCHFERM PV .

    $défaut  réduction par utilisation de la règle 24 (instrv)


État 105

   57 bloc_if: IF PAROUVR expression PARFERM instrv . ELSE instrv
   58        | IF PAROUVR expression PARFERM instrv .

    ELSE  décalage et aller à l'état 108

    ELSE      [réduction par utilisation de la règle 58 (bloc_if)]
    $défaut  réduction par utilisation de la règle 58 (bloc_if)


État 106

   64 bloc_while: WHILE PAROUVR expression PARFERM instrv .

    $défaut  réduction par utilisation de la règle 64 (bloc_while)


État 107

   63 bloc_for: FOR PAROUVR expression_for PV expression_for . PV expression_for PV PARFERM instrv

    PV  décalage et aller à l'état 109


État 108

   57 bloc_if: IF PAROUVR expression PARFERM instrv ELSE . instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    PV           décalage et aller à l'état 22
    RETURN       décalage et aller à l'état 23
    ACCOLOUVR    décalage et aller à l'état 15
    IF           décalage et aller à l'état 24
    WHILE        décalage et aller à l'état 25
    FOR          décalage et aller à l'état 26
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction         aller à l'état 30
    instrv                 aller à l'état 110
    expression             aller à l'état 33
    valeur_variable        aller à l'état 34
    affectation            aller à l'état 35
    structure_de_controle  aller à l'état 36
    bloc_if                aller à l'état 37
    bloc_boucle            aller à l'état 38
    bloc_for               aller à l'état 39
    bloc_while             aller à l'état 40
    bloc                   aller à l'état 41


État 109

   63 bloc_for: FOR PAROUVR expression_for PV expression_for PV . expression_for PV PARFERM instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    $défaut  réduction par utilisation de la règle 62 (expression_for)

    appel_fonction   aller à l'état 30
    expression       aller à l'état 87
    valeur_variable  aller à l'état 34
    affectation      aller à l'état 35
    expression_for   aller à l'état 111


État 110

   57 bloc_if: IF PAROUVR expression PARFERM instrv ELSE instrv .

    $défaut  réduction par utilisation de la règle 57 (bloc_if)


État 111

   63 bloc_for: FOR PAROUVR expression_for PV expression_for PV expression_for . PV PARFERM instrv

    PV  décalage et aller à l'état 112


État 112

   63 bloc_for: FOR PAROUVR expression_for PV expression_for PV expression_for PV . PARFERM instrv

    PARFERM  décalage et aller à l'état 113


État 113

   63 bloc_for: FOR PAROUVR expression_for PV expression_for PV expression_for PV PARFERM . instrv

    IDENTIFIANT  décalage et aller à l'état 20
    PAROUVR      décalage et aller à l'état 21
    PV           décalage et aller à l'état 22
    RETURN       décalage et aller à l'état 23
    ACCOLOUVR    décalage et aller à l'état 15
    IF           décalage et aller à l'état 24
    WHILE        décalage et aller à l'état 25
    FOR          décalage et aller à l'état 26
    VAL          décalage et aller à l'état 27
    CARACTERE    décalage et aller à l'état 28
    NOT          décalage et aller à l'état 29

    appel_fonction         aller à l'état 30
    instrv                 aller à l'état 114
    expression             aller à l'état 33
    valeur_variable        aller à l'état 34
    affectation            aller à l'état 35
    structure_de_controle  aller à l'état 36
    bloc_if                aller à l'état 37
    bloc_boucle            aller à l'état 38
    bloc_for               aller à l'état 39
    bloc_while             aller à l'état 40
    bloc                   aller à l'état 41


État 114

   63 bloc_for: FOR PAROUVR expression_for PV expression_for PV expression_for PV PARFERM instrv .

    $défaut  réduction par utilisation de la règle 63 (bloc_for)
